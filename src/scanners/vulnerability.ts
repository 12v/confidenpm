import { VulnerabilityResult, PackageInfo } from '../types';
import { SafePackageHandler } from './sandbox';

export class VulnerabilityScanner {
  private sandbox: SafePackageHandler;

  constructor(sandbox: SafePackageHandler) {
    this.sandbox = sandbox;
  }

  async scan(extractDir: string, packageInfo: PackageInfo): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      const trivyOutput = await this.runTrivy(extractDir);
      vulnerabilities.push(...this.parseTrivyOutput(trivyOutput));

      const auditOutput = await this.runNpmAudit(extractDir);
      vulnerabilities.push(...this.parseAuditOutput(auditOutput));

    } catch (error) {
      console.error('Vulnerability scan error:', error);
    }

    return vulnerabilities;
  }

  private async runTrivy(extractDir: string): Promise<string> {
    try {
      const output = await this.sandbox.runInSandbox(
        'trivy',
        [
          'fs',
          '--security-checks', 'vuln',
          '--format', 'json',
          '--quiet',
          '--no-progress',
          '--timeout', '5m',
          '--skip-dirs', 'node_modules',
          extractDir
        ],
        extractDir
      );
      return output;
    } catch (error) {
      return '{}';
    }
  }

  private async runNpmAudit(extractDir: string): Promise<string> {
    try {
      const output = await this.sandbox.runInSandbox(
        'npm',
        ['audit', '--json', '--package-lock-only', '--audit-level=low'],
        extractDir
      );
      return output;
    } catch (error) {
      return '{}';
    }
  }

  private parseTrivyOutput(output: string): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      const data = JSON.parse(output);

      if (data.Results) {
        for (const result of data.Results) {
          if (result.Vulnerabilities) {
            for (const vuln of result.Vulnerabilities) {
              vulnerabilities.push({
                severity: this.normalizeSeverity(vuln.Severity),
                cve: vuln.VulnerabilityID,
                title: vuln.Title || vuln.VulnerabilityID,
                description: vuln.Description || 'No description available',
                fixedVersion: vuln.FixedVersion,
                affectedPackage: vuln.PkgName || 'unknown'
              });
            }
          }
        }
      }
    } catch (error) {
      console.error('Error parsing Trivy output:', error);
    }

    return vulnerabilities;
  }

  private parseAuditOutput(output: string): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      const data = JSON.parse(output);

      if (data.vulnerabilities) {
        for (const [, vuln] of Object.entries(data.vulnerabilities) as any) {
          vulnerabilities.push({
            severity: this.normalizeSeverity(vuln.severity),
            cve: vuln.cves?.[0] || `NPM-${vuln.id}`,
            title: vuln.title || 'Unknown vulnerability',
            description: vuln.overview || 'No description available',
            fixedVersion: vuln.fixAvailable?.version,
            affectedPackage: vuln.name || 'unknown'
          });
        }
      }
    } catch (error) {
      console.error('Error parsing npm audit output:', error);
    }

    return vulnerabilities;
  }

  private normalizeSeverity(severity: string): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    const normalized = severity?.toUpperCase();
    switch (normalized) {
      case 'CRITICAL':
        return 'CRITICAL';
      case 'HIGH':
        return 'HIGH';
      case 'MEDIUM':
      case 'MODERATE':
        return 'MEDIUM';
      case 'LOW':
      case 'INFO':
      default:
        return 'LOW';
    }
  }
}